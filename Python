##########
BASIC

# integer division
print(5/2) #perform normal divison ...returns 2.5
print(5//2)  #perform integer divison ...returns 2

# Exponent
print(10 ** 3)

# remainder
print(10%3)

# strings
print('neha' + 'neha')
print(3*'neha')

// result 
nehaneha
nehanehaneha

//
use a \ to let the compiler print apostrophe

name = 'Neha'
print(name[2])
// returns h
print(name[-1])
// returns the last i.e a

print(name[0:2])
// returns Ne

print(name[2:])
// returns ha

a = "hdjdljnidbvjldhvdvfbf"
a[1:9:4]

// from index position 1 to 9 i.e from [djdljnid]....only the 4th position would get printed....dj will be printed in the end

// use len() function to find the length of the string

###############
PYTHON STRING FUNCTION

**String Initialization and Concatenation:**
   - `str()`: Converts an object into a string.
   - `+` operator: Concatenates two strings.
   - `*` operator: Repeats a string a specified number of times.

**Accessing Characters:**
   - `[]` indexing: Access individual characters in a string by index.
   - `[:]` slicing: Extract a substring by specifying a range of indices
.
**Basic String Methods:**
   - `str.capitalize()`: Returns a copy of the string with the first character capitalized and the rest lowercase.
   - `str.lower()`: Returns a copy of the string converted to lowercase.
   - `str.upper()`: Returns a copy of the string converted to uppercase.
   - `str.title()`: Returns a titlecased version of the string (first character of each word capitalized, others lowercase).

**Searching and Finding:**
   - `str.find(substring)`: Returns the lowest index where the substring is found.
   - `str.index(substring)`: Returns the lowest index where the substring is found (similar to `find` but raises ValueError if not found).
   - `str.count(substring)`: Returns the number of non-overlapping occurrences of a substring in the string.

**String Manipulation:**
   - `str.replace(old, new)`: Returns a copy of the string with all occurrences of `old` replaced by `new`.
   - `str.strip()`: Returns a copy of the string with leading and trailing whitespace removed.
   - `str.lstrip()`: Returns a copy of the string with leading whitespace removed.
   - `str.rstrip()`: Returns a copy of the string with trailing whitespace removed.

 **Splitting and Joining:**
   - `str.split(sep=None, maxsplit=-1)`: Splits the string into a list of substrings using `sep` as the delimiter.
   - `str.join(iterable)`: Concatenates strings in an iterable with `str` as the separator.

**Checking and Formatting:**
   - `str.startswith(prefix)`: Returns `True` if the string starts with the specified prefix.
   - `str.endswith(suffix)`: Returns `True` if the string ends with the specified suffix.
   - `str.format()`: Formats the string into a nicer output (can include placeholders `{}`).

 **Checking and Validation:**
   - `str.isalpha()`: Returns `True` if all characters in the string are alphabetic.
   - `str.isdigit()`: Returns `True` if all characters in the string are digits.
   - `str.isalnum()`: Returns `True` if all characters in the string are alphanumeric.

**Conversion and Encoding:**
   - `str.encode(encoding='utf-8', errors='strict')`: Returns an encoded version of the string as bytes.
   - `str.decode(encoding='utf-8', errors='strict')`: Decodes the bytes object into a string using the specified encoding.

**Formatting:**
    - `str.center(width[, fillchar])`: Returns a centered string of specified width.
    - `str.ljust(width[, fillchar])`: Returns a left-justified string of specified width.
    - `str.rjust(width[, fillchar])`: Returns a right-justified string of specified width.


->
str = "neha"
str[1] = "R"
I cannot do this
i cannot assign values with index positions


###############
LISTS

# Create a list
my_list = [1, 2, 3, 4, 5]

# Adding elements
my_list.append(6)
print(my_list)  # Output: [1, 2, 3, 4, 5, 6]

# Extending list
my_list.extend([7, 8, 9])
print(my_list)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]

# Inserting element
my_list.insert(3, 10)
print(my_list)  # Output: [1, 2, 3, 10, 4, 5, 6, 7, 8, 9]

# Removing element
my_list.remove(6)
print(my_list)  # Output: [1, 2, 3, 10, 4, 5, 7, 8, 9]

# Popping element
popped_value = my_list.pop()
print(popped_value)  # Output: 9
print(my_list)       # Output: [1, 2, 3, 10, 4, 5, 7, 8]

# Finding element
index_of_3 = my_list.index(3)
print(index_of_3)  # Output: 2

# Counting occurrences
count_of_4 = my_list.count(4)
print(count_of_4)  # Output: 1

# Sorting
my_list.sort()
print(my_list)  # Output: [1, 2, 3, 4, 5, 7, 8, 10]
list.sort(reverse = True) # prints in descending order

# Reversing
my_list.reverse()
print(my_list)  # Output: [10, 8, 7, 5, 4, 3, 2, 1]

# Clearing list
my_list.clear()
print(my_list)  # Output: []


//take user input for List and Nested List using For Loop and List Comprehension

neha = []
for i in range(0,3):
    neha.append(int(input()))
print(neha)

n = 3
neha = [int(input()) for i in range (n)]   // takes input as integers
neha = [input() for i in range (n)]        // take input as string


//
big = []
ran = int(input("total elements in the larger list"))
for i in range(0,ran):
    small = []
    size = int(input("enter the size of the sub list"))
    for j in range(0,size):
        val = int(input())
        small.append(val)

    big.append(small)
print(big)

total elements in the larger list3
enter the size of the sub list1
3
enter the size of the sub list2
2
3
enter the size of the sub list3
12
2
3
[[3], [2, 3], [12, 2, 3]]


//
n = int(input("Enter the size of the list "))
num_list = list(int(num) for num in input("Enter the list items separated by space ").strip().split())[:n]

print("User list: ", num_list)

Enter the size of the list 5
Enter the list items separated by space 2 4 6 8 10

User list:  [2, 4, 6, 8, 10]


//
for i in range(0,3):
    neha = list(input().split())              // takes in string input
    neha = list(map(int,input().split()))     // takes in int input
print(neha)

// nested list to a normal list
flatList = [element for innerList in lis for element in innerList]


// PROGRAM - 1
m = int(input())
n = int(input())

total = (2*m)+(2*n)
arr = []

for i in range(0,m+n):
    neha = list(map(int,input().split()))
    arr.append(neha)
print(arr)

def Sort(sub_li):
    l = len(sub_li)
    for i in range(0, l):
        for j in range(0, l-i-1):
            if (sub_li[j][1] < sub_li[j + 1][1]):
                tempo = sub_li[j]
                sub_li[j]= sub_li[j + 1]
                sub_li[j + 1]= tempo
    return sub_li

arr = Sort(arr)
print(arr)

latest = list(dict((x[0],x) for x in sorted(arr, key=len,reverse= False)).values())

print(latest)

latest = [element for innerList in latest for element in innerList]
print(latest)


latest = [latest[i:i+2] for i in range(0, len(latest), 2)]
print(latest)

l = []

for i in latest:
    l.insert(0, i)
print(l)


for i in l:
        print(*i


####################
TUPLES

# Creating a tuple
my_tuple = (1, 2, 3, 4, 5)

# Accessing elements
print(my_tuple[0])  # Output: 1
print(my_tuple[-1])  # Output: 5
print(my_tuple[1:4])  # Output: (2, 3, 4)

# Concatenating tuples
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
concatenated_tuple = tuple1 + tuple2
print(concatenated_tuple)  # Output: (1, 2, 3, 4, 5, 6)

# Repeating tuples
repeated_tuple = tuple1 * 3
print(repeated_tuple)  # Output: (1, 2, 3, 1, 2, 3, 1, 2, 3)

# Length of tuple
print(len(my_tuple))  # Output: 5

# Checking membership
print(2 in my_tuple)  # Output: True
print(6 in my_tuple)  # Output: False

# Counting occurrences
count_of_3 = my_tuple.count(3)
print(count_of_3)  # Output: 1

# Finding index
index_of_4 = my_tuple.index(4)
print(index_of_4)  # Output: 3

# Tuple packing and unpacking
packed_tuple = 1, 2, 3
a, b, c = packed_tuple
print(a, b, c)  # Output: 1 2 3


####################
DICTIONARY

# Creating a dictionary
my_dict = {'name': 'John', 'age': 30, 'city': 'New York'}

# Accessing elements
print(my_dict['name'])  # Output: John
print(my_dict.get('age'))  # Output: 30

# Modifying elements
my_dict['city'] = 'San Francisco'
print(my_dict)  # Output: {'name': 'John', 'age': 30, 'city': 'San Francisco'}

# Adding elements
my_dict['gender'] = 'Male'
print(my_dict)  # Output: {'name': 'John', 'age': 30, 'city': 'San Francisco', 'gender': 'Male'}

# Removing elements
del my_dict['age']
print(my_dict)  # Output: {'name': 'John', 'city': 'San Francisco', 'gender': 'Male'}

# Iterating through a dictionary
for key in my_dict:
    print(key, ':', my_dict[key])

# Dictionary methods
print(my_dict.keys())    # Output: dict_keys(['name', 'city', 'gender'])
print(my_dict.values())  # Output: dict_values(['John', 'San Francisco', 'Male'])
print(my_dict.items())   # Output: dict_items([('name', 'John'), ('city', 'San Francisco'), ('gender', 'Male')])

my_dict.update({'age': 31, 'city': 'San Francisco'})
print(my_dict)                  # Output: {'name': 'Alice', 'age': 31, 'city': 'San Francisco', 'gender': 'Female'}

# Removing elements
removed_value = my_dict.pop('gender')
print(removed_value)            # Output: Female
print(my_dict)                  # Output: {'name': 'Alice', 'age': 31, 'city': 'San Francisco'}

key_value_pair = my_dict.popitem()
print(key_value_pair)           # Output: ('city', 'San Francisco')
print(my_dict)                  # Output: {'name': 'Alice', 'age': 31}

del my_dict['age']
print(my_dict)                  # Output: {'name': 'Alice'}

# Dictionary views
print(my_dict.keys())           # Output: dict_keys(['name'])
print(my_dict.values())         # Output: dict_values(['Alice'])
print(my_dict.items())          # Output: dict_items([('name', 'Alice')])

# Checking membership
print('name' in my_dict)        # Output: True
print('age' not in my_dict)     # Output: True

# Clearing dictionary
my_dict.clear()
print(my_dict)                  # Output: {}

A dictionary can have key value pairs where value can be another dictionary or tuple or set

dixt = {
 "name" : ["neha","altaf"],
"age" :(24,25)
}


-> d["key'] 
this should return the value of the key but if the key is not present it throws error

d.get("key")
this also returns the value but if key is not present it doesn't throw error



#################
SETS
-> ses are mutable kyuki we can add and remove elements but sets ke andar ke elements ko we cannot change isiliye list ya tupple we cannot add inside a set

# Creating a set
my_set = {1, 2, 3, 4, 5}

# Adding elements
my_set.add(6)
print(my_set)  # Output: {1, 2, 3, 4, 5, 6}

# Removing elements
my_set.remove(3)
print(my_set)  # Output: {1, 2, 4, 5, 6}

# Iterating through a set
for element in my_set:
    print(element)

# Set methods
other_set = {4, 5, 6, 7, 8}

print(my_set.union(other_set))                 # Output: {1, 2, 4, 5, 6, 7, 8}
print(my_set.intersection(other_set))          # Output: {4, 5, 6}
print(my_set.difference(other_set))            # Output: {1, 2}
print(my_set.symmetric_difference(other_set))  # Output: {1, 2, 7, 8}

# Note: Sets are unordered collections, so the output order may vary.

# empty set= s()
# empty dictionary = s{}


#
a = set()
a.add(20)
a.add(20.0)
a.add("20:)
print(len(a))   // return 2 as it compares the numerical value so for int and float its same and since its set so no duplicate values allowed hence len = 2


##################
PRINTING

n = int(input())

for rows in range(1, n+1):
    print("  "* (n-1),end="")
    print("*"* ((2*rows)-1),end="")
    print("")



#####################
FILE INPUT/OUTPUT

# Syntax: open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

# Basic opening
file = open('example.txt', 'r')
# ... operations
file.close()

# Automatically closes the file
with open('example.txt', 'r') as file:
    # File operations here
    content = file.read()
# File is automatically closed here

# Method 1: read()
with open('example.txt', 'r') as file:
    content = file.read()  # Reads entire file as string
    print(content)

# Method 2: readlines()
with open('example.txt', 'r') as file:
    lines = file.readlines()  # Returns list of lines
    for line in lines:
        print(line.strip())  # strip() removes newline characters

# Method 1: Using file object as iterator (Memory efficient)
with open('example.txt', 'r') as file:
    for line in file:  # Reads one line at a time
        print(f"Line: {line.strip()}")

# Method 2: readline()
with open('example.txt', 'r') as file:
    line1 = file.readline()  # Read first line
    line2 = file.readline()  # Read second line
    # Continue as needed...

with open('example.txt', 'r') as file:
    # Read first 100 characters
    chunk = file.read(100)
    
    # Read next 50 characters
    chunk2 = file.read(50)

with open('example.txt', 'r') as file:
    # Get current position
    position = file.tell()
    print(f"Starting at position: {position}")
    
    # Read some data
    data = file.read(50)
    
    # Move to a specific position
    file.seek(0)  # Go to beginning
    file.seek(10)  # Go to 10th byte
    file.seek(0, 2)  # Go to end of file (2 means from end)

# Writing to a new file (creates or overwrites)
with open('output.txt', 'w') as file:
    file.write("Hello, World!\n")
    file.write("This is a new line.\n")
    
    # Writing multiple lines
    lines = ["Line 1\n", "Line 2\n", "Line 3\n"]
    file.writelines(lines)

# Append to existing file (creates if doesn't exist)
with open('output.txt', 'a') as file:
    file.write("This is appended text.\n")
    file.write("Another appended line.\n")

Mode	Description	File Position
'r'	Read only (default)	Beginning
'w'	Write only (truncates if exists)	Beginning
'a'	Append only	End
'x'	Exclusive creation (fails if exists)	Beginning
'r+'	Read and write	Beginning
'w+'	Write and read (truncates if exists)	Beginning
'a+'	Append and read	End
'rb'	Read binary
'wb'	Write binary
'ab'	Append binary

# Read mode (default)
with open('file.txt', 'r') as f:  # or just open('file.txt')
    pass

# Write mode (creates new or overwrites)
with open('file.txt', 'w') as f:
    f.write("New content")

# Append mode
with open('file.txt', 'a') as f:
    f.write("\nAppended content")

# Read and write mode
with open('file.txt', 'r+') as f:
    content = f.read()
    f.write("\nAdditional content")

# Exclusive creation (fails if file exists)
try:
    with open('newfile.txt', 'x') as f:
        f.write("Creating new file")
except FileExistsError:
    print("File already exists!")

# Binary mode for images, PDFs, etc.
with open('image.jpg', 'rb') as f:
    binary_data = f.read()

-> CSV
import csv

# Reading CSV
with open('data.csv', 'r') as file:
    csv_reader = csv.reader(file)
    for row in csv_reader:
        print(row)  # Each row is a list

# Reading CSV as dictionary
with open('data.csv', 'r') as file:
    csv_reader = csv.DictReader(file)
    for row in csv_reader:
        print(row['column_name'])  # Access by column name

# Writing CSV
data = [['Name', 'Age', 'City'],
        ['John', '25', 'New York'],
        ['Alice', '30', 'London']]

with open('output.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

# Writing CSV as dictionary
fieldnames = ['Name', 'Age', 'City']
data_dict = [{'Name': 'John', 'Age': '25', 'City': 'NY'},
             {'Name': 'Alice', 'Age': '30', 'City': 'LDN'}]

with open('output.csv', 'w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerows(data_dict)

-> JSON
import json

# Writing JSON
data = {
    "name": "John",
    "age": 30,
    "city": "New York",
    "hobbies": ["reading", "gaming"]
}

with open('data.json', 'w') as file:
    json.dump(data, file, indent=4)  # indent for pretty printing

# Reading JSON
with open('data.json', 'r') as file:
    loaded_data = json.load(file)
    print(loaded_data['name'])

# JSON string operations
json_string = json.dumps(data)  # Convert dict to JSON string
python_dict = json.loads(json_string)  # Convert JSON string to dict


-> Text Files with Different Encodings
# Specifying encoding
with open('file.txt', 'r', encoding='utf-8') as file:
    content = file.read()

# Common encodings: utf-8, ascii, latin-1, cp1252
# Handling encoding errors
with open('file.txt', 'r', encoding='utf-8', errors='ignore') as file:
    content = file.read()  # ignores invalid characters

with open('file.txt', 'r', encoding='utf-8', errors='replace') as file:
    content = file.read()  # replaces invalid chars with ï¿½


->
# Reading binary file
with open('image.jpg', 'rb') as file:
    binary_data = file.read()
    # Process binary data...

# Writing binary file
with open('copy.jpg', 'wb') as file:
    file.write(binary_data)

# Working with binary chunks
chunk_size = 1024  # 1KB chunks
with open('large_file.bin', 'rb') as file:
    while True:
        chunk = file.read(chunk_size)
        if not chunk:
            break
        # Process chunk


->
with open('example.txt', 'r+') as file:
    # Check if file is readable/writable
    print(f"Readable: {file.readable()}")
    print(f"Writable: {file.writable()}")
    
    # Get file descriptor
    print(f"File descriptor: {file.fileno()}")
    
    # Check if file is closed
    print(f"Closed: {file.closed}")
    
    # Get file mode
    print(f"Mode: {file.mode}")
    
    # Get file name
    print(f"Name: {file.name}")
    
    # Flush buffer (force write to disk)
    file.write("Some data")
    file.flush()
    
# Check after with block
print(f"Closed after with block: {file.closed}")


->
with open('example.txt', 'r+') as file:
    # Write some data
    file.write("Line 1\nLine 2\nLine 3\n")
    
    # Go to beginning
    file.seek(0)
    
    # Read first 10 characters
    print(file.read(10))
    
    # Get current position
    pos = file.tell()
    print(f"Current position: {pos}")
    
    # Go back 5 characters
    file.seek(-5, 1)  # 1 means from current position
    
    # Truncate file (keep first 20 bytes)
    file.truncate(20)


->
import mmap

with open('large_file.bin', 'r+b') as file:
    # Memory map the file
    with mmap.mmap(file.fileno(), 0) as mm:
        # Access like a bytearray
        print(mm[:10])  # First 10 bytes
        
        # Modify data
        mm[0:5] = b'HELLO'
        
        # Search within file
        position = mm.find(b'search_string')

-> Temporary FIles
import tempfile

# Create temporary file
with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp:
    tmp.write("Temporary data")
    tmp_path = tmp.name  # Get file path

# Create temporary directory
with tempfile.TemporaryDirectory() as tmpdir:
    print(f"Temporary directory: {tmpdir}")
    # Create files in tmpdir


-> File Locking
import fcntl  # Unix/Linux only
import os

with open('file.txt', 'r+') as file:
    # Lock the file
    fcntl.flock(file.fileno(), fcntl.LOCK_EX)
    
    # Perform operations
    file.write("Exclusive access")
    
    # Unlock (automatically when file closes)
    fcntl.flock(file.fileno(), fcntl.LOCK_UN)


-> Zip Files
import gzip
import zipfile

# Gzip files
with gzip.open('file.txt.gz', 'rt') as f:  # 't' for text mode
    content = f.read()

with gzip.open('file.txt.gz', 'wt') as f:
    f.write("Compressed content")

# Zip files
with zipfile.ZipFile('archive.zip', 'r') as zipf:
    # List contents
    print(zipf.namelist())
    
    # Extract specific file
    zipf.extract('file.txt', 'extract_dir/')
    
    # Read file without extracting
    with zipf.open('file.txt') as f:
        content = f.read()

# Create zip file
with zipfile.ZipFile('archive.zip', 'w') as zipf:
    zipf.write('file1.txt')
    zipf.write('file2.txt')


-> Meta Data
import os

# Get file stats
stats = os.stat('file.txt')
print(f"Size: {stats.st_size} bytes")
print(f"Last modified: {stats.st_mtime}")
print(f"Last accessed: {stats.st_atime}")
print(f"Creation time: {stats.st_ctime}")

# Check file properties
print(f"Exists: {os.path.exists('file.txt')}")
print(f"Is file: {os.path.isfile('file.txt')}")
print(f"Is directory: {os.path.isdir('file.txt')}")

# Get absolute path
abs_path = os.path.abspath('file.txt')
print(f"Absolute path: {abs_path}")


-> Monitoring
import time
import os

def monitor_file(file_path):
    """Monitor file for changes"""
    last_modified = os.path.getmtime(file_path)
    
    while True:
        time.sleep(1)  # Check every second
        current_modified = os.path.getmtime(file_path)
        
        if current_modified != last_modified:
            print(f"File {file_path} has been modified!")
            last_modified = current_modified

->
from pathlib import Path

p = Path("data.txt")

# Read
content = p.read_text()

# Write
p.write_text("Writing using pathlib")




############################################
OOPS

Four Pillars of OOP
Encapsulation - Bundling data and methods
Inheritance - Creating new classes from existing ones
Polymorphism - Using a single interface for different types
Abstraction - Hiding complex implementation details


-> Defining a Class
class Dog:
    """A simple Dog class"""
    
    # Class attribute (shared by all instances)
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        """Constructor/Initializer"""
        # Instance attributes (unique to each instance)
        self.name = name
        self.age = age
    
    def bark(self):
        """Instance method"""
        return f"{self.name} says Woof!"
    
    def get_info(self):
        """Another instance method"""
        return f"{self.name} is {self.age} years old"


-> Creating Objects (Instances)
# Creating instances
dog1 = Dog("Buddy", 3)
dog2 = Dog("Max", 5)

# Accessing attributes
print(dog1.name)          # Buddy
print(dog2.age)           # 5
print(Dog.species)        # Canis familiaris (class attribute)

# Calling methods
print(dog1.bark())        # Buddy says Woof!
print(dog2.get_info())    # Max is 5 years old

# Modifying attributes
dog1.age = 4
dog1.breed = "Golden Retriever"  # Can add attributes dynamically

# Checking instance
print(isinstance(dog1, Dog))      # True
print(type(dog1))                 # <class '__main__.Dog'>


class Person:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        return f"Hello, I'm {self.name}"

p = Person("Alice")
# These are equivalent:
print(p.greet())           # Python converts this to:
print(Person.greet(p))     # Explicitly passing instance


-> Constructors and Initialization <a name="constructors"></a>
class Rectangle:
    def __init__(self, width, height):
        """Called when creating new instance"""
        self.width = width
        self.height = height
        self.area = width * height  # Can compute during init

rect = Rectangle(10, 5)
print(rect.area)  # 50


class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Called before __init__, creates the instance"""
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, value):
        if not hasattr(self, 'initialized'):
            self.value = value
            self.initialized = True

s1 = Singleton(10)
s2 = Singleton(20)
print(s1 is s2)  # True (same instance)
print(s1.value)  # 10 (first init preserved)



-> Multiple Constructors (Using Class Methods)
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
    
    @classmethod
    def from_string(cls, date_string):
        """Alternative constructor"""
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)
    
    @classmethod
    def today(cls):
        """Another alternative constructor"""
        import datetime
        today = datetime.date.today()
        return cls(today.year, today.month, today.day)

# Different ways to create instances
d1 = Date(2024, 1, 15)
d2 = Date.from_string("2024-01-15")
d3 = Date.today()


-> Class Attributes vs Instance Attributes <a name="attributes"></a>
class Employee:
    # Class attribute (shared)
    company = "Tech Corp"
    employee_count = 0
    
    def __init__(self, name, salary):
        # Instance attributes (unique)
        self.name = name
        self.salary = salary
        Employee.employee_count += 1  # Modify class attribute
    
    def display(self):
        print(f"{self.name} works at {self.company}")

# Usage
e1 = Employee("Alice", 50000)
e2 = Employee("Bob", 60000)

print(Employee.company)      # Tech Corp
print(e1.company)           # Tech Corp
print(e2.company)           # Tech Corp

# Modifying class attribute affects all instances
Employee.company = "New Corp"
print(e1.company)           # New Corp
print(e2.company)           # New Corp

# Instance attribute shadows class attribute
e1.company = "Individual Corp"
print(e1.company)           # Individual Corp (instance)
print(e2.company)           # New Corp (class)
print(Employee.company)     # New Corp

print(f"Total employees: {Employee.employee_count}")  # 2


-> Namespace Resolution Order
class MyClass:
    class_var = "Class Variable"
    
    def __init__(self):
        self.instance_var = "Instance Variable"
    
    def show(self):
        print(self.instance_var)  # Instance first
        print(self.class_var)     # Then class
        print(MyClass.class_var)  # Direct class access

obj = MyClass()
obj.show()


-> Instance Methods
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
    
    # Instance method - operates on instance
    def deposit(self, amount):
        self.balance += amount
        return self.balance
    
    def withdraw(self, amount):
        if amount <= self.balance:
            self.balance -= amount
            return amount
        return "Insufficient funds"

account = BankAccount(100)
print(account.deposit(50))   # 150
print(account.withdraw(30))  # 30


-> Class Methods
class Pizza:
    sizes = ["small", "medium", "large"]
    
    def __init__(self, toppings, size="medium"):
        self.toppings = toppings
        self.size = size
    
    @classmethod
    def validate_size(cls, size):
        """Class method - works with class, not instance"""
        if size not in cls.sizes:
            raise ValueError(f"Size must be one of {cls.sizes}")
        return size
    
    @classmethod
    def cheese_pizza(cls, size="medium"):
        """Factory method - creates instances"""
        return cls(["cheese"], size)

# Using class method without instance
print(Pizza.validate_size("large"))  # large

# Factory method
pizza = Pizza.cheese_pizza("large")


-> Static Methods
class MathOperations:
    @staticmethod
    def add(x, y):
        """Static method - no self or cls parameter"""
        return x + y
    
    @staticmethod
    def multiply(x, y):
        return x * y

# Can be called on class or instance
print(MathOperations.add(5, 3))       # 8
math = MathOperations()
print(math.multiply(5, 3))           # 15


-> Inheritance <a name="inheritance"></a>
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "Some sound"
    
    def move(self):
        return f"{self.name} is moving"

class Dog(Animal):  # Dog inherits from Animal
    def __init__(self, name, breed):
        super().__init__(name)  # Call parent constructor
        self.breed = breed
    
    def speak(self):  # Method overriding
        return "Woof!"
    
    def fetch(self):  # New method
        return f"{self.name} is fetching"

class Cat(Animal):
    def speak(self):
        return "Meow!"

# Usage
animal = Animal("Generic")
dog = Dog("Buddy", "Golden Retriever")
cat = Cat("Whiskers")

print(animal.speak())  # Some sound
print(dog.speak())     # Woof!
print(cat.speak())     # Meow!
print(dog.move())      # Buddy is moving (inherited)
print(dog.fetch())     # Buddy is fetching (specific to Dog)



class Parent:
    def __init__(self, value):
        self.value = value
    
    def show(self):
        print(f"Parent value: {self.value}")

class Child(Parent):
    def __init__(self, value, extra):
        super().__init__(value)  # Call parent's __init__
        self.extra = extra
    
    def show(self):
        super().show()  # Call parent's show()
        print(f"Child extra: {self.extra}")

child = Child(10, "extra")
child.show()


class A: pass
class B(A): pass
class C(B): pass

obj = C()

print(isinstance(obj, C))     # True
print(isinstance(obj, B))     # True
print(isinstance(obj, A))     # True

print(issubclass(C, B))       # True
print(issubclass(C, A))       # True
print(issubclass(B, A))       # True
print(issubclass(A, C))       # False


-> Polymorphism <a name="polymorphism"></a>
-> Method Overriding
class Shape:
    def area(self):
        raise NotImplementedError("Subclasses must implement area()")

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2

# Polymorphic behavior
shapes = [Rectangle(5, 4), Circle(3), Rectangle(2, 3)]

for shape in shapes:
    print(f"Area: {shape.area()}")
# Output: Area: 20, Area: 28.27431, Area: 6


-> Operator Overloading
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        """Overload + operator"""
        return Vector(self.x + other.x, self.y + other.y)
    
    def __mul__(self, scalar):
        """Overload * operator"""
        return Vector(self.x * scalar, self.y * scalar)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(2, 3)
v2 = Vector(4, 5)

v3 = v1 + v2  # Uses __add__
v4 = v1 * 3   # Uses __mul__

print(v3)  # Vector(6, 8)
print(v4)  # Vector(6, 9)


-> Duck Typing
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

class Car:
    def speak(self):
        return "Vroom!"

def make_sound(obj):
    """Works with any object that has speak() method"""
    return obj.speak()

# All work because they have speak() method
print(make_sound(Dog()))  # Woof!
print(make_sound(Cat()))  # Meow!
print(make_sound(Car()))  # Vroom!



-> Encapsulation 
class BankAccount:
    def __init__(self, balance):
        # Single underscore: "protected" (convention only)
        self._balance = balance
        
        # Double underscore: "private" (name mangling)
        self.__secret_pin = 1234
    
    def get_balance(self):
        return self._balance
    
    def __get_secret(self):
        return self.__secret_pin

account = BankAccount(1000)

# Can still access (but shouldn't)
print(account._balance)            # 1000 (convention warns you)

# Name mangling makes it harder
# print(account.__secret_pin)      # AttributeError
print(account._BankAccount__secret_pin)  # 1234 (but don't do this!)

# print(account.__get_secret())    # AttributeError


class Person:
    def __init__(self, name, age):
        self.name = name
        self._age = age  # Protected attribute
    
    @property
    def age(self):
        """Getter"""
        return self._age
    
    @age.setter
    def age(self, value):
        """Setter with validation"""
        if value < 0:
            raise ValueError("Age cannot be negative")
        self._age = value
    
    @age.deleter
    def age(self):
        """Deleter"""
        print("Deleting age...")
        del self._age

person = Person("Alice", 25)

# Using as property (not method)
print(person.age)      # 25 (calls getter)

person.age = 30        # Calls setter
print(person.age)      # 30

# person.age = -5      # ValueError: Age cannot be negative

del person.age         # Calls deleter



class Temperature:
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("Temperature below absolute zero")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """Read-only property"""
        return (self._celsius * 9/5) + 32
    
    @property
    def kelvin(self):
        """Read-only property"""
        return self._celsius + 273.15

temp = Temperature(25)
print(temp.celsius)      # 25
print(temp.fahrenheit)   # 77.0
print(temp.kelvin)       # 298.15

temp.celsius = 100       # Works
# temp.fahrenheit = 212  # AttributeError (no setter)



from abc import ABC, abstractmethod

class Flyable(ABC):
    @abstractmethod
    def fly(self):
        pass

class Swimmable(ABC):
    @abstractmethod
    def swim(self):
        pass

class Walkable(ABC):
    @abstractmethod
    def walk(self):
        pass

class Duck(Flyable, Swimmable, Walkable):
    def fly(self):
        return "Duck flying"
    
    def swim(self):
        return "Duck swimming"
    
    def walk(self):
        return "Duck walking"

class Fish(Swimmable):
    def swim(self):
        return "Fish swimming"

duck = Duck()
fish = Fish()

print(duck.fly())   # Duck flying
print(fish.swim())  # Fish swimming
# fish.fly()        # AttributeError



-> Common Dunder Methods
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages
    
    # String representation
    def __str__(self):
        return f"'{self.title}' by {self.author}"
    
    def __repr__(self):
        return f"Book('{self.title}', '{self.author}', {self.pages})"
    
    # Length
    def __len__(self):
        return self.pages
    
    # Comparison
    def __eq__(self, other):
        return self.title == other.title and self.author == other.author
    
    def __lt__(self, other):
        return self.pages < other.pages
    
    # Callable
    def __call__(self):
        return f"Reading {self.title}..."
    
    # Container behavior
    def __getitem__(self, key):
        if key == 'title':
            return self.title
        elif key == 'author':
            return self.author
        elif key == 'pages':
            return self.pages
        raise KeyError(f"No attribute {key}")

book1 = Book("Python Basics", "John Doe", 300)
book2 = Book("Advanced Python", "Jane Smith", 500)

print(str(book1))      # 'Python Basics' by John Doe
print(repr(book1))     # Book('Python Basics', 'John Doe', 300)
print(len(book1))      # 300
print(book1 == book2)  # False
print(book1 < book2)   # True
print(book1())         # Reading Python Basics...
print(book1['title'])  # Python Basics



->Context Manager (__enter__, __exit__)
class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.connection = None
    
    def __enter__(self):
        """Called when entering with block"""
        print(f"Connecting to {self.db_name}...")
        self.connection = f"Connection to {self.db_name}"
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Called when exiting with block"""
        print(f"Closing connection to {self.db_name}...")
        self.connection = None
        if exc_type:
            print(f"Exception occurred: {exc_type}")
        # Return True to suppress exception
        return False
    
    def execute(self, query):
        print(f"Executing: {query}")
        return "Query result"

# Usage as context manager
with DatabaseConnection("mydb") as db:
    result = db.execute("SELECT * FROM users")
    print(result)
# Automatically closes connection



class Person:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name
    
    def get_full_name(self):
        return f"{self.first_name} {self.last_name}"
    
    def set_full_name(self, name):
        first, last = name.split(" ")
        self.first_name = first
        self.last_name = last
    
    def del_full_name(self):
        self.first_name = None
        self.last_name = None
    
    # Create property using property() function
    full_name = property(get_full_name, set_full_name, del_full_name)

p = Person("John", "Doe")
print(p.full_name)          # John Doe

p.full_name = "Jane Smith"
print(p.first_name)         # Jane
print(p.last_name)          # Smith

del p.full_name
print(p.first_name)         # None



class Circle:
    def __init__(self, radius):
        self.radius = radius
        self._area = None  # Cache
    
    @property
    def area(self):
        if self._area is None:
            print("Calculating area...")
            self._area = 3.14159 * self.radius ** 2
        return self._area

circle = Circle(5)
print(circle.area)  # Calculating area... 78.53975
print(circle.area)  # 78.53975 (cached, no calculation)
circle.radius = 10
print(circle.area)  # 78.53975 (still old value - cache issue!)


class Circle:
    def __init__(self, radius):
        self._radius = radius
        self._area = None
    
    @property
    def radius(self):
        return self._radius
    
    @radius.setter
    def radius(self, value):
        self._radius = value
        self._area = None  # Invalidate cache
    
    @property
    def area(self):
        if self._area is None:
            print("Calculating area...")
            self._area = 3.14159 * self._radius ** 2
        return self._area

circle = Circle(5)
print(circle.area)     # Calculating area... 78.53975
print(circle.area)     # 78.53975 (cached)
circle.radius = 10     # Invalidates cache
print(circle.area)     # Calculating area... 314.159 (recalculated)


-> Multiple Inheritance
class Flyable:
    def fly(self):
        return "Flying"
    
    def move(self):
        return "Moving through air"

class Swimmable:
    def swim(self):
        return "Swimming"
    
    def move(self):
        return "Moving through water"

class Duck(Flyable, Swimmable):
    def quack(self):
        return "Quack!"
    
    # Override if needed
    def move(self):
        return "Waddling"

duck = Duck()
print(duck.fly())     # Flying
print(duck.swim())    # Swimming
print(duck.quack())   # Quack!
print(duck.move())    # Waddling (from Duck)


-> Method Resolution Order (MRO)
class A:
    def method(self):
        return "A"

class B(A):
    def method(self):
        return "B"

class C(A):
    def method(self):
        return "C"

class D(B, C):
    pass

d = D()
print(d.method())               # B (MRO: D -> B -> C -> A)
print(D.__mro__)                # (<class '__main__.D'>, <class '__main__.B'>, 
                                #  <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
print(D.mro())                  # Same as above

# Diamond Problem Solution
class Base:
    def method(self):
        return "Base"

class Left(Base):
    def method(self):
        return "Left"

class Right(Base):
    def method(self):
        return "Right"

class Child(Left, Right):
    pass

c = Child()
print(c.method())               # Left (MRO: Child -> Left -> Right -> Base)
print(Child.__mro__)


-> super() with Multiple Inheritance
class A:
    def __init__(self):
        print("A init")
        super().__init__()

class B:
    def __init__(self):
        print("B init")
        super().__init__()

class C(A, B):
    def __init__(self):
        print("C init")
        super().__init__()

c = C()
# Output:
# C init
# A init
# B init

print(C.__mro__)  # C -> A -> B -> object



-> Abstract Base Classes (ABC)
from abc import ABC, abstractmethod, abstractproperty

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass
    
    @abstractproperty
    def name(self):
        pass
    
    def describe(self):
        return f"This is a {self.name}"

class Rectangle(Shape):
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    @property
    def name(self):
        return "Rectangle"
    
    def area(self):
        return self._width * self._height
    
    def perimeter(self):
        return 2 * (self._width + self._height)

class Circle(Shape):
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def name(self):
        return "Circle"
    
    def area(self):
        return 3.14159 * self._radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self._radius

shapes = [Rectangle(4, 5), Circle(3)]
for shape in shapes:
    print(f"{shape.name}: Area={shape.area()}, Perimeter={shape.perimeter()}")



-> Registering Classes as Virtual Subclasses
from abc import ABC

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

class Dog:  # Doesn't inherit from Animal
    def speak(self):
        return "Woof!"

# Register Dog as a virtual subclass
Animal.register(Dog)

print(issubclass(Dog, Animal))  # True
print(isinstance(Dog(), Animal))  # True

# But doesn't enforce implementation
class Cat:
    pass

Animal.register(Cat)
cat = Cat()
# cat.speak()  # AttributeError - no enforcement



-> Object Creation and Destruction
class Resource:
    def __new__(cls, *args, **kwargs):
        print(f"__new__ called with {args}")
        instance = super().__new__(cls)
        return instance
    
    def __init__(self, name):
        print(f"__init__ called with {name}")
        self.name = name
    
    def __del__(self):
        print(f"__del__ called for {self.name}")

res = Resource("MyResource")
del res  # Triggers __del__



-> Attribute Access
class Config:
    def __init__(self):
        self._data = {}
    
    def __getattr__(self, name):
        """Called when attribute not found"""
        if name in self._data:
            return self._data[name]
        raise AttributeError(f"No config '{name}'")
    
    def __setattr__(self, name, value):
        """Called when setting any attribute"""
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            self._data[name] = value
    
    def __getitem__(self, key):
        """Allows dict-like access"""
        return self._data[key]
    
    def __setitem__(self, key, value):
        self._data[key] = value

config = Config()
config.host = "localhost"      # Uses __setattr__
config.port = 8080
print(config.host)             # Uses __getattr__
print(config['port'])          # Uses __getitem__


->Context Manager with Error Handling
class FileHandler:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        
        # Handle specific exceptions
        if exc_type is IOError:
            print(f"IOError occurred: {exc_val}")
            return True  # Suppress the exception
        
        # Return False to propagate other exceptions
        return False

# Usage
try:
    with FileHandler("nonexistent.txt", "r") as f:
        content = f.read()
except IOError:
    print("Exception was suppressed in __exit__")


-> Callable Objects
class Adder:
    def __init__(self, n):
        self.n = n
    
    def __call__(self, x):
        return self.n + x

add5 = Adder(5)
print(add5(10))      # 15 (instance is callable)
print(callable(add5))  # True

# Can be used as decorator
class Counter:
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"Function called {self.count} times")
        return self.func(*args, **kwargs)

@Counter
def greet(name):
    return f"Hello, {name}"

print(greet("Alice"))
print(greet("Bob"))



-> Metaclasses 
class Meta(type):
    """Metaclass that adds attributes to classes"""
    def __new__(cls, name, bases, dct):
        # Add a class attribute to all classes using this metaclass
        dct['created_by_meta'] = True
        return super().__new__(cls, name, bases, dct)
    
    def __init__(cls, name, bases, dct):
        super().__init__(name, bases, dct)
        # Register class in a registry
        if not hasattr(cls, 'registry'):
            cls.registry = []
        cls.registry.append(cls)

class MyClass(metaclass=Meta):
    pass

print(MyClass.created_by_meta)  # True
print(MyClass.registry)         # [<class '__main__.MyClass'>]



-> Singleton using Metaclass
class SingletonMeta(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self, connection_string):
        self.connection_string = connection_string

db1 = Database("mysql://localhost")
db2 = Database("postgres://localhost")
print(db1 is db2)           # True
print(db1.connection_string)  # mysql://localhost


-> Validation Metaclass
class ValidateFieldsMeta(type):
    def __new__(cls, name, bases, dct):
        # Check if class has required fields
        required_fields = dct.get('required_fields', [])
        
        # Add validation to __init__
        original_init = dct.get('__init__')
        
        def new_init(self, *args, **kwargs):
            if original_init:
                original_init(self, *args, **kwargs)
            
            # Validate required fields
            for field in required_fields:
                if not hasattr(self, field) or getattr(self, field) is None:
                    raise ValueError(f"{field} is required")
        
        dct['__init__'] = new_init
        return super().__new__(cls, name, bases, dct)

class Person(metaclass=ValidateFieldsMeta):
    required_fields = ['name', 'age']
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Valid
p1 = Person("Alice", 25)

# Invalid - will raise ValueError
# p2 = Person(None, 25)
























